const { pool } = require('../config/database');
const Papa = require('papaparse');
const { v4: uuidv4 } = require('uuid');
const { normalizePhoneNumber } = require('../utils/phoneUtils');

class ContactController {
       // Update contact list name
    static async updateList(req, res) {
        try {
            const { id } = req.params;
            const { name } = req.body;
            const businessId = req.user.businessId;

            if (!name) {
                return res.status(400).json({ success: false, message: 'List name is required' });
            }

            // First verify the list exists and belongs to business
            const [existing] = await pool.execute(
                `SELECT cl.id FROM contact_lists cl
                 WHERE cl.id = ? AND cl.business_id = ?`, [id, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact list not found' });
            }

            // Update list
            await pool.execute(
                'UPDATE contact_lists SET name = ? WHERE id = ?', [name, id]
            );

            res.json({
                success: true,
                message: 'Contact list updated successfully'
            });
        } catch (error) {
            if (error.code === 'ER_DUP_ENTRY') {
                return res.status(400).json({ success: false, message: 'A list with this name already exists' });
            }
            console.error('Error updating contact list:', error);
            res.status(500).json({ success: false, message: 'Failed to update contact list' });
        }
    }

    // Delete contact list
    static async deleteList(req, res) {
        try {
            const { id } = req.params;
            const businessId = req.user.businessId;

            // First verify the list exists and belongs to business
            const [existing] = await pool.execute(
                `SELECT cl.id FROM contact_lists cl
                 WHERE cl.id = ? AND cl.business_id = ?`, [id, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact list not found' });
            }

            // Delete all contacts in the list first
            await pool.execute('DELETE FROM contacts WHERE list_id = ?', [id]);

            // Delete the list
            await pool.execute('DELETE FROM contact_lists WHERE id = ?', [id]);

            res.json({
                success: true,
                message: 'Contact list deleted successfully'
            });
        } catch (error) {
            console.error('Error deleting contact list:', error);
            res.status(500).json({ success: false, message: 'Failed to delete contact list' });
        }
    }
    // Create a new contact list
    static async createList(req, res) {
        try {
            const { name } = req.body;
            const userId = req.user.id;
            const businessId = req.user.businessId;

            if (!name) {
                return res.status(400).json({ success: false, message: 'List name is required' });
            }

            await pool.execute(
                'INSERT INTO contact_lists (name, user_id, business_id) VALUES (?, ?, ?)', [name, userId, businessId]
            );

            // Fetch the actual UUID generated by MySQL (since insertId is not valid for UUID PKs)
            const [rows] = await pool.execute(
                'SELECT id FROM contact_lists WHERE name = ? AND business_id = ? ORDER BY created_at DESC LIMIT 1',
                [name, businessId]
            );

            const createdId = rows && rows.length ? rows[0].id : null;

            res.status(201).json({
                success: true,
                message: 'Contact list created successfully',
                data: { id: createdId, name }
            });
        } catch (error) {
            if (error.code === 'ER_DUP_ENTRY') {
                return res.status(400).json({ success: false, message: 'A list with this name already exists' });
            }
            console.error('Error creating contact list:', error);
            res.status(500).json({ success: false, message: 'Failed to create contact list' });
        }
    }

    // Get all contact lists for business
    static async getLists(req, res) {
        try {
            const businessId = req.user.businessId;

            const [lists] = await pool.execute(
                `SELECT cl.id, cl.name FROM contact_lists cl
                 WHERE cl.business_id = ? ORDER BY cl.created_at DESC`, [businessId]
            );

            res.json({
                success: true,
                data: lists
            });
        } catch (error) {
            console.error('Error fetching contact lists:', error);
            res.status(500).json({ success: false, message: 'Failed to fetch contact lists' });
        }
    }

    // Create a new contact
    static async createContact(req, res) {
        try {
            const { fname, lname, wanumber, email, listId, newListName, customFields } = req.body;
            const userId = req.user.id;
            const businessId = req.user.businessId;

            // Validate required fields
            if (!wanumber) {
                return res.status(400).json({ success: false, message: 'WhatsApp number is required' });
            }

            // Normalize phone number
            const normalizedWanumber = normalizePhoneNumber(wanumber);
            if (!normalizedWanumber) {
                return res.status(400).json({ success: false, message: 'Invalid WhatsApp number format' });
            }

            let finalListId = listId || null;

            // Create new list if requested and listId was not already provided
            if (newListName && !finalListId) {
                await pool.execute(
                    'INSERT INTO contact_lists (name, user_id, business_id) VALUES (?, ?, ?)', [newListName, userId, businessId]
                );

                const [rows] = await pool.execute(
                    'SELECT id FROM contact_lists WHERE name = ? AND business_id = ? ORDER BY created_at DESC LIMIT 1',
                    [newListName, businessId]
                );
                finalListId = rows && rows.length ? rows[0].id : null;
            }

            if (!finalListId) {
                return res.status(400).json({ success: false, message: 'List ID or new list name is required' });
            }

            // Prepare custom_fields JSON
            const customFieldsJson = customFields && Object.keys(customFields).length > 0 
                ? JSON.stringify(customFields) 
                : null;

            // Insert contact with normalized phone number (subscribed defaults to TRUE)
            const [result] = await pool.execute(
                'INSERT INTO contacts (fname, lname, wanumber, email, custom_fields, list_id, business_id, subscribed) VALUES (?, ?, ?, ?, ?, ?, ?, TRUE)', 
                [fname || '', lname || '', normalizedWanumber, email || '', customFieldsJson, finalListId, businessId]
            );

            res.status(201).json({
                success: true,
                message: 'Contact created successfully',
                data: { id: result.insertId }
            });
        } catch (error) {
            if (error.code === 'ER_DUP_ENTRY') {
                return res.status(400).json({ success: false, message: 'This WhatsApp number already exists in the selected list' });
            }
            console.error('Error creating contact:', error);
            res.status(500).json({ success: false, message: 'Failed to create contact' });
        }
    }

    // Import contacts from CSV
    static async importContacts(req, res) {
        try {
            const { listName, fieldMappings } = req.body; // fieldMappings: { csvColumn: contactField }
            const userId = req.user.id;
            const businessId = req.user.businessId;
            if (!req.file) {
                return res.status(400).json({ success: false, message: 'CSV file is required' });
            }

            if (!listName) {
                return res.status(400).json({ success: false, message: 'List name is required' });
            }

            const csvData = req.file.buffer.toString('utf8');
            const parsed = Papa.parse(csvData, {
                header: true,
                skipEmptyLines: true
            });

            if (parsed.errors.length > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'CSV parsing error',
                    errors: parsed.errors
                });
            }

            // Get CSV columns
            const csvColumns = parsed.data.length > 0 ? Object.keys(parsed.data[0]) : [];
            
            // Parse field mappings if provided as string
            let mappings = {};
            if (fieldMappings) {
                try {
                    mappings = typeof fieldMappings === 'string' ? JSON.parse(fieldMappings) : fieldMappings;
                } catch (e) {
                    console.error('Error parsing fieldMappings:', e);
                    mappings = {};
                }
            }
            
            // Auto-map common column names if not explicitly mapped
            const autoMappings = {
                'first_name': 'fname',
                'firstname': 'fname',
                'fname': 'fname',
                'last_name': 'lname',
                'lastname': 'lname',
                'lname': 'lname',
                'number': 'wanumber',
                'phone': 'wanumber',
                'phone_number': 'wanumber',
                'whatsapp': 'wanumber',
                'whatsapp_number': 'wanumber',
                'wanumber': 'wanumber',
                'email': 'email',
                'e-mail': 'email'
            };

            // Fixed fields that go directly to contact columns
            const fixedFields = ['fname', 'lname', 'wanumber', 'email'];
            
            // Process CSV data with field mappings
            const processedData = parsed.data.map(row => {
                const contact = {
                    fname: '',
                    lname: '',
                    wanumber: '',
                    email: '',
                    customFields: {},
                    subscribe: row.subscribe || row.subscribed || 'true'
                };

                // Process each CSV column
                csvColumns.forEach(csvCol => {
                    // Get the mapped field name (from explicit mapping or auto-mapping)
                    let fieldName = mappings[csvCol] || autoMappings[csvCol.toLowerCase()];
                    
                    // Get the value (even if empty, we need to process it for required fields)
                    const value = row[csvCol] ? row[csvCol].toString().trim() : '';
                    
                    // If no mapping found, treat it as a custom field (use column name as field name)
                    if (!fieldName) {
                        // Convert CSV column name to snake_case for custom field
                        fieldName = csvCol.toLowerCase().replace(/[^a-z0-9]+/g, '_');
                        if (value) {
                            contact.customFields[fieldName] = value;
                        }
                    } else if (fixedFields.includes(fieldName)) {
                        // Map to fixed field (even if empty, set it so validation can check)
                        contact[fieldName] = value;
                    } else {
                        // Map to custom field
                        if (value) {
                            contact.customFields[fieldName] = value;
                        }
                    }
                });

                return contact;
            });

            // Validate processed data (wanumber is required)
            const validationResult = ContactController.validateCSVData(processedData.map(c => ({
                fname: c.fname,
                lname: c.lname,
                wanumber: c.wanumber,
                email: c.email
            })));

            if (validationResult.errors.length > 0) {
                return res.status(400).json({
                    success: false,
                    message: 'CSV validation failed',
                    errors: validationResult.errors
                });
            }

            // Create the contact list and get its UUID
            await pool.execute(
                'INSERT INTO contact_lists (name, user_id, business_id) VALUES (?, ?, ?)', [listName, userId, businessId]
            );

            // Get the inserted list's UUID
            const [lists] = await pool.execute(
                'SELECT id FROM contact_lists WHERE name = ? AND business_id = ? ORDER BY created_at DESC LIMIT 1', [listName, businessId]
            );

            if (lists.length === 0) {
                throw new Error('Failed to retrieve created contact list');
            }

            const listId = lists[0].id;

            // Auto-create field definitions for unmapped custom fields
            const customFieldNames = new Set();
            processedData.forEach(contact => {
                Object.keys(contact.customFields).forEach(fieldName => {
                    customFieldNames.add(fieldName);
                });
            });

            // Create field definitions for custom fields that don't exist yet
            if (customFieldNames.size > 0) {
                for (const fieldName of customFieldNames) {
                    try {
                        // Check if field definition already exists
                        const [existing] = await pool.execute(
                            `SELECT id FROM contact_field_definitions 
                             WHERE business_id = ? AND list_id ${listId ? '= ?' : 'IS NULL'} AND field_name = ?`,
                            listId ? [businessId, listId, fieldName] : [businessId, fieldName]
                        );

                        if (existing.length === 0) {
                            // Create field definition
                            const fieldId = uuidv4();
                            await pool.execute(
                                `INSERT INTO contact_field_definitions 
                                 (id, business_id, list_id, field_name, field_type, is_predefined, is_active) 
                                 VALUES (?, ?, ?, ?, 'text', FALSE, TRUE)`,
                                [fieldId, businessId, listId || null, fieldName]
                            );
                        }
                    } catch (error) {
                        // Ignore duplicate entry errors, log others
                        if (error.code !== 'ER_DUP_ENTRY') {
                            console.error(`Error creating field definition for ${fieldName}:`, error);
                        }
                    }
                }
            }

            // Prepare batch insert with custom fields
            const contacts = processedData.map(contact => {
                const subscribed = contact.subscribe.toString().toLowerCase() === 'true' || 
                                 contact.subscribe.toString().toLowerCase() === 'yes' || 
                                 contact.subscribe === '1';
                
                // Normalize phone number
                const normalizedWanumber = normalizePhoneNumber(contact.wanumber);
                
                // Prepare custom_fields JSON
                const customFieldsJson = Object.keys(contact.customFields).length > 0 
                    ? JSON.stringify(contact.customFields) 
                    : null;
                
                return [
                    contact.fname || '',
                    contact.lname || '',
                    normalizedWanumber || contact.wanumber,
                    contact.email || '',
                    customFieldsJson,
                    listId,
                    businessId,
                    subscribed
                ];
            });

            // Batch insert contacts
            await pool.query(
                'INSERT INTO contacts (fname, lname, wanumber, email, custom_fields, list_id, business_id, subscribed) VALUES ?', [contacts]
            );

            res.json({
                success: true,
                message: `Successfully imported ${contacts.length} contacts`,
                data: { listId, count: contacts.length }
            });
        } catch (error) {
            console.error('Error importing contacts:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to import contacts',
                error: process.env.NODE_ENV === 'development' ? error.message : undefined
            });
        }
    }

    // FIX: Proper static method definition
    static validateCSVData(data) {
        const errors = [];
        const validData = [];
        const seenNumbers = new Set();

        if (!data || data.length === 0) {
            errors.push('CSV file is empty or contains no valid data');
            return { errors, validData };
        }

        // Check if wanumber column exists
        if (!data[0].hasOwnProperty('wanumber')) {
            errors.push('CSV must contain a "wanumber" column');
            return { errors, validData };
        }

        data.forEach((row, index) => {
            const rowNumber = index + 2; // +2 because header is row 1 and array is 0-based

            // Validate WhatsApp number
            const waNumber = row.wanumber ? row.wanumber.toString().trim() : null;
            if (!waNumber) {
                errors.push(`Row ${rowNumber}: WhatsApp number is required`);
                return;
            }

            // Validate number format (basic check)
            const isValidNumber = /^(\+|\d)[0-9]{7,15}$/.test(waNumber);
            if (!isValidNumber) {
                errors.push(`Row ${rowNumber}: Invalid WhatsApp number format`);
                return;
            }

            // Normalize phone number for duplicate checking
            const normalizedNumber = normalizePhoneNumber(waNumber);
            if (!normalizedNumber) {
                errors.push(`Row ${rowNumber}: Invalid WhatsApp number format`);
                return;
            }

            // Check for duplicates in this batch (using normalized numbers)
            if (seenNumbers.has(normalizedNumber)) {
                errors.push(`Row ${rowNumber}: Duplicate WhatsApp number found in CSV`);
                return;
            }
            seenNumbers.add(normalizedNumber);

            // Prepare valid data with normalized phone number
            // Handle subscribe column (optional, defaults to true)
            const subscribeValue = row.subscribe || row.subscribed || 'true';
            validData.push({
                fname: row.fname || '',
                lname: row.lname || '',
                wanumber: normalizedNumber,
                email: row.email || '',
                subscribe: subscribeValue
            });
        });

        return { errors, validData };
    }

    // Helper method to merge custom_fields with fixed fields
    static mergeContactFields(contact) {
        const merged = { ...contact };
        
        // Parse custom_fields JSON if it exists
        if (contact.custom_fields) {
            try {
                const customFields = typeof contact.custom_fields === 'string' 
                    ? JSON.parse(contact.custom_fields) 
                    : contact.custom_fields;
                
                // Merge custom fields into the contact object
                // Only merge primitive values to avoid nested objects in React rendering
                Object.keys(customFields).forEach(key => {
                    const value = customFields[key];
                    if (value !== null && value !== undefined) {
                        // Only merge primitive types (string, number, boolean)
                        // Convert objects/arrays to JSON string to prevent React rendering errors
                        if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
                            // Nested object - convert to string
                            merged[key] = JSON.stringify(value);
                        } else {
                            // Primitive value or array - use as is
                            merged[key] = value;
                        }
                    }
                });
            } catch (e) {
                console.error('Error parsing custom_fields:', e);
            }
        }
        
        // Remove the raw custom_fields property (it's now merged)
        delete merged.custom_fields;
        
        return merged;
    }

    // Get contacts with optional list filter
    static async getContacts(req, res) {
        try {
            const { listId } = req.query;
            const businessId = req.user.businessId;

            let query = `
                SELECT c.id, c.fname, c.lname, c.wanumber, c.email, c.custom_fields, c.list_id, c.subscribed, l.name as list_name
                FROM contacts c
                JOIN contact_lists l ON c.list_id = l.id
                WHERE c.business_id = ?
            `;
            const params = [businessId];

            if (listId) {
                query += ' AND c.list_id = ?';
                params.push(listId);
            }

            query += ' ORDER BY c.created_at DESC';

            const [contacts] = await pool.execute(query, params);

            // Merge custom_fields with fixed fields for each contact
            const mergedContacts = contacts.map(contact => ContactController.mergeContactFields(contact));

            res.json({
                success: true,
                data: mergedContacts
            });
        } catch (error) {
            console.error('Error fetching contacts:', error);
            res.status(500).json({ success: false, message: 'Failed to fetch contacts' });
        }
    }

    // Get single contact by ID
    static async getContactById(req, res) {
        try {
            const { id } = req.params;
            const businessId = req.user.businessId;

            const [contacts] = await pool.execute(
                `SELECT c.id, c.fname, c.lname, c.wanumber, c.email, c.custom_fields, c.list_id, c.subscribed, l.name as list_name
                FROM contacts c
                JOIN contact_lists l ON c.list_id = l.id
                WHERE c.id = ? AND c.business_id = ?`, [id, businessId]
            );

            if (contacts.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact not found' });
            }

            // Merge custom_fields with fixed fields
            const mergedContact = ContactController.mergeContactFields(contacts[0]);

            res.json({
                success: true,
                data: mergedContact
            });
        } catch (error) {
            console.error('Error fetching contact:', error);
            res.status(500).json({ success: false, message: 'Failed to fetch contact' });
        }
    }

    // Update contact
    static async updateContact(req, res) {
        try {
            const { id } = req.params;
            const { fname, lname, wanumber, email, listId, customFields } = req.body;
            const businessId = req.user.businessId;

            // First verify the contact exists and belongs to business
            const [existing] = await pool.execute(
                `SELECT c.id FROM contacts c
                JOIN contact_lists l ON c.list_id = l.id
                WHERE c.id = ? AND c.business_id = ?`, [id, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact not found' });
            }

            // Normalize phone number before updating
            const normalizedWanumber = normalizePhoneNumber(wanumber);
            if (!normalizedWanumber) {
                return res.status(400).json({ success: false, message: 'Invalid WhatsApp number format' });
            }

            // Prepare custom_fields JSON
            const customFieldsJson = customFields && Object.keys(customFields).length > 0 
                ? JSON.stringify(customFields) 
                : null;

            console.log('Update contact - customFields:', customFields);
            console.log('Update contact - customFieldsJson:', customFieldsJson);

            // Update contact with normalized phone number and custom fields
            await pool.execute(
                'UPDATE contacts SET fname = ?, lname = ?, wanumber = ?, email = ?, custom_fields = ?, list_id = ? WHERE id = ?', 
                [fname, lname, normalizedWanumber, email, customFieldsJson, listId, id]
            );

            res.json({
                success: true,
                message: 'Contact updated successfully'
            });
        } catch (error) {
            if (error.code === 'ER_DUP_ENTRY') {
                return res.status(400).json({ success: false, message: 'This WhatsApp number already exists in the selected list' });
            }
            console.error('Error updating contact:', error);
            res.status(500).json({ success: false, message: 'Failed to update contact' });
        }
    }

    // Delete contact
    static async deleteContact(req, res) {
        try {
            const { id } = req.params;
            const businessId = req.user.businessId;

            // First verify the contact exists and belongs to business
            const [existing] = await pool.execute(
                `SELECT c.id FROM contacts c
                WHERE c.id = ? AND c.business_id = ?`, [id, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact not found' });
            }

            await pool.execute('DELETE FROM contacts WHERE id = ?', [id]);

            res.json({
                success: true,
                message: 'Contact deleted successfully'
            });
        } catch (error) {
            console.error('Error deleting contact:', error);
            res.status(500).json({ success: false, message: 'Failed to delete contact' });
        }
    }

    // Bulk delete contacts
    static async deleteContacts(req, res) {
        try {
            const { ids } = req.body;
            const businessId = req.user.businessId;

            if (!ids || !Array.isArray(ids) || ids.length === 0) {
                return res.status(400).json({ success: false, message: 'Contact IDs are required' });
            }

            // Verify all contacts exist and belong to business
            const placeholders = ids.map(() => '?').join(',');
            const [existing] = await pool.execute(
                `SELECT c.id FROM contacts c
                WHERE c.id IN (${placeholders}) AND c.business_id = ?`, [...ids, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'No valid contacts found' });
            }

            // Get the IDs that actually belong to the business
            const validIds = existing.map(row => row.id);

            // Delete all valid contacts
            const deletePlaceholders = validIds.map(() => '?').join(',');
            await pool.execute(
                `DELETE FROM contacts WHERE id IN (${deletePlaceholders})`, validIds
            );

            res.json({
                success: true,
                message: `Successfully deleted ${validIds.length} contact(s)`,
                deletedCount: validIds.length
            });
        } catch (error) {
            console.error('Error deleting contacts:', error);
            res.status(500).json({ success: false, message: 'Failed to delete contacts' });
        }
    }
    static async getAllByBusiness(businessId, subscribedOnly = true) {
        let query = `
            SELECT 
                c.id, c.fname, c.lname, c.wanumber, c.email, c.custom_fields,
                c.list_id as listId, c.subscribed, l.name as list_name
            FROM contacts c
            JOIN contact_lists l ON c.list_id = l.id
            WHERE c.business_id = ?
        `;
        
        if (subscribedOnly) {
            query += ' AND c.subscribed = TRUE';
        }
        
        query += ' ORDER BY c.created_at DESC';
        
        const [contacts] = await pool.execute(query, [businessId]);
        // Merge custom_fields with fixed fields
        return contacts.map(contact => ContactController.mergeContactFields(contact));
    }
    static async getByList(listId, businessId, subscribedOnly = true) {
        let query = `
            SELECT c.id, c.fname, c.lname, c.wanumber, c.email, c.custom_fields, c.subscribed
           FROM contacts c
           JOIN contact_lists l ON c.list_id = l.id
           WHERE l.id = ? AND c.business_id = ?
        `;
        
        if (subscribedOnly) {
            query += ' AND c.subscribed = TRUE';
        }
        
        query += ' ORDER BY c.created_at DESC';
        
        const [contacts] = await pool.execute(query, [listId, businessId]);
        // Merge custom_fields with fixed fields
        return contacts.map(contact => ContactController.mergeContactFields(contact));
    }
    static async getSendingLists(req, res) {
            try {
                const businessId = req.user.businessId;

                const [lists] = await pool.execute(
                    `SELECT cl.id, cl.name, COUNT(c.id) as contactCount 
       FROM contact_lists cl
       LEFT JOIN contacts c ON cl.id = c.list_id
       WHERE cl.business_id = ?
       GROUP BY cl.id, cl.name
       ORDER BY cl.created_at DESC`, [businessId]
                );

                res.json({
                    success: true,
                    data: lists
                });
            } catch (error) {
                console.error('Error fetching sending lists:', error);
                res.status(500).json({
                    success: false,
                    message: 'Failed to fetch contact lists for sending'
                });
            }
        }
        // Add this method to ContactController
    static async checkListNameAvailability(req, res) {
        console.log("list function called")
        try {
            const { listName } = req.query;
            const businessId = req.user.businessId;

            if (!listName) {
                return res.status(400).json({
                    success: false,
                    message: 'List name is required'
                });
            }

            const [existing] = await pool.execute(
                `SELECT cl.id FROM contact_lists cl
                 WHERE cl.name = ? AND cl.business_id = ?`, [listName.trim(), businessId]
            );

            res.json({
                success: true,
                available: existing.length === 0,
                message: existing.length > 0 ? 'List name already exists' : 'List name is available'
            });
        } catch (error) {
            console.error('Error checking list name availability:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to check list name availability'
            });
        }
    }

    // Get unsubscribed contacts
    static async getUnsubscribedContacts(req, res) {
        try {
            const businessId = req.user.businessId;

            const [contacts] = await pool.execute(
                `SELECT c.id, c.fname, c.lname, c.wanumber, c.email, c.custom_fields, c.list_id, c.subscribed, l.name as list_name
                FROM contacts c
                JOIN contact_lists l ON c.list_id = l.id
                WHERE c.business_id = ? AND c.subscribed = FALSE
                ORDER BY c.updated_at DESC`, [businessId]
            );

            // Merge custom_fields with fixed fields
            const mergedContacts = contacts.map(contact => ContactController.mergeContactFields(contact));

            res.json({
                success: true,
                data: mergedContacts
            });
        } catch (error) {
            console.error('Error fetching unsubscribed contacts:', error);
            res.status(500).json({ success: false, message: 'Failed to fetch unsubscribed contacts' });
        }
    }

    // Resubscribe a contact
    static async resubscribeContact(req, res) {
        try {
            const { id } = req.params;
            const businessId = req.user.businessId;

            // Verify the contact exists and belongs to business
            const [existing] = await pool.execute(
                `SELECT c.id FROM contacts c
                WHERE c.id = ? AND c.business_id = ?`, [id, businessId]
            );

            if (existing.length === 0) {
                return res.status(404).json({ success: false, message: 'Contact not found' });
            }

            await pool.execute(
                'UPDATE contacts SET subscribed = TRUE, updated_at = NOW() WHERE id = ?', [id]
            );

            res.json({
                success: true,
                message: 'Contact resubscribed successfully'
            });
        } catch (error) {
            console.error('Error resubscribing contact:', error);
            res.status(500).json({ success: false, message: 'Failed to resubscribe contact' });
        }
    }

}


module.exports = ContactController;